var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a, _b;
import { Type } from "@google/genai";
import { isLlmAgent } from "../agents/llm_agent.js";
import { InMemoryMemoryService } from "../memory/in_memory_memory_service.js";
import { Runner } from "../runner/runner.js";
import { InMemorySessionService } from "../sessions/in_memory_session_service.js";
import { GoogleLLMVariant } from "../utils/variant_utils.js";
import { BaseTool } from "./base_tool.js";
import { ForwardingArtifactService } from "./forwarding_artifact_service.js";
const AGENT_TOOL_SIGNATURE_SYMBOL = Symbol.for("google.adk.agentTool");
function isAgentTool(obj) {
  return typeof obj === "object" && obj !== null && AGENT_TOOL_SIGNATURE_SYMBOL in obj && obj[AGENT_TOOL_SIGNATURE_SYMBOL] === true;
}
class AgentTool extends (_b = BaseTool, _a = AGENT_TOOL_SIGNATURE_SYMBOL, _b) {
  constructor(config) {
    super(
      { name: config.agent.name, description: config.agent.description || "" }
    );
    /** A unique symbol to identify ADK agent tool class. */
    this[_a] = true;
    this.agent = config.agent;
    this.skipSummarization = config.skipSummarization || false;
  }
  _getDeclaration() {
    let declaration;
    if (isLlmAgent(this.agent) && this.agent.inputSchema) {
      declaration = {
        name: this.name,
        description: this.description,
        // TODO(b/425992518): We should not use the agent's input schema as is.
        // It should be validated and possibly transformed. Consider similar
        // logic to one we have in Python ADK.
        parameters: this.agent.inputSchema
      };
    } else {
      declaration = {
        name: this.name,
        description: this.description,
        parameters: {
          type: Type.OBJECT,
          properties: {
            "request": {
              type: Type.STRING
            }
          },
          required: ["request"]
        }
      };
    }
    if (this.apiVariant !== GoogleLLMVariant.GEMINI_API) {
      const hasOutputSchema = isLlmAgent(this.agent) && this.agent.outputSchema;
      declaration.response = hasOutputSchema ? { type: Type.OBJECT } : { type: Type.STRING };
    }
    return declaration;
  }
  async runAsync({ args, toolContext }) {
    var _a2, _b2;
    if (this.skipSummarization) {
      toolContext.actions.skipSummarization = true;
    }
    const hasInputSchema = isLlmAgent(this.agent) && this.agent.inputSchema;
    const content = {
      role: "user",
      parts: [
        {
          // TODO(b/425992518): Should be validated. Consider similar
          // logic to one we have in Python ADK.
          text: hasInputSchema ? JSON.stringify(args) : args["request"]
        }
      ]
    };
    const runner = new Runner({
      appName: this.agent.name,
      agent: this.agent,
      artifactService: new ForwardingArtifactService(toolContext),
      sessionService: new InMemorySessionService(),
      memoryService: new InMemoryMemoryService(),
      credentialService: toolContext.invocationContext.credentialService
    });
    const session = await runner.sessionService.createSession({
      appName: this.agent.name,
      userId: "tmp_user",
      state: toolContext.state.toRecord()
    });
    let lastEvent;
    try {
      for (var iter = __forAwait(runner.runAsync({
        userId: session.userId,
        sessionId: session.id,
        newMessage: content
      })), more, temp, error; more = !(temp = await iter.next()).done; more = false) {
        const event = temp.value;
        if (event.actions.stateDelta) {
          toolContext.state.update(event.actions.stateDelta);
        }
        lastEvent = event;
      }
    } catch (temp) {
      error = [temp];
    } finally {
      try {
        more && (temp = iter.return) && await temp.call(iter);
      } finally {
        if (error)
          throw error[0];
      }
    }
    if (!((_b2 = (_a2 = lastEvent == null ? void 0 : lastEvent.content) == null ? void 0 : _a2.parts) == null ? void 0 : _b2.length)) {
      return "";
    }
    const hasOutputSchema = isLlmAgent(this.agent) && this.agent.outputSchema;
    const mergedText = lastEvent.content.parts.map((part) => part.text).filter((text) => text).join("\n");
    return hasOutputSchema ? JSON.parse(mergedText) : mergedText;
  }
}
export {
  AgentTool,
  isAgentTool
};
